//
//  Bindings.h
//  Handoff-Swift
//
//  Created by Alexander Heinrich on 19.06.19.
//  Copyright Â© 2019 Alexander Heinrich. All rights reserved.
//

//#import <Foundation/Foundation.h>

#ifndef Bindings_h
#define Bindings_h


typedef uint8_t ccec25519key[32];
typedef ccec25519key ccec25519secretkey;
typedef ccec25519key ccec25519pubkey;
typedef ccec25519key ccec25519base;

typedef uint8_t ccec25519signature[64];


/*!
 @function    cced25519_sign
 @abstract    Signs a message using a secret key.
 
 @param      di      A valid descriptor for a 512 bit hash function for the platform
 @param        sig        Receives the 64-byte signature.
 @param        len        Number of bytes to sign.
 @param        msg        Data to sign.
 @param        pk        32-byte public key as generated by cced25519_make_key_pair().
 @param        sk        32-byte secret key as generated by cced25519_make_key_pair().
 */
void cced25519_sign_compat(ccec25519signature sig, const void *msg, size_t len, const ccec25519key pk, const const ccec25519key sk);


/*!
 @function    cced25519_verify
 @abstract    Verifies a signed message using a public key.
 
 @param      di      A valid descriptor for a 512 bit hash function for the platform
 @param        len        Number of bytes of data to verify.
 @param        msg        Data to verify.
 @param        sig        64-byte signature to verify data against.
 @param        pk        32-byte public key. Should have been generated by the peer using
 cced25519_make_key_pair().
 
 @result        0=Signed message is valid. Non-zero=Bad message.
 */
int cced25519_verify_compat(const void *msg, size_t len, const const ccec25519signature sig, const const ccec25519key pk);




/*!
 @function        cccurve25519
 @abstract        Perform Curve25519 Diffie-Hellman.
 http://cr.yp.to/ecdh.html
 
 @param      out  Output shared secret or public key.
 @param      sk   Input secret key.
 @param      base Input basepoint (for computing a shared secret)
 or NULL (for computing a public key).
 */

void cccurve25519(ccec25519key out,
                  const ccec25519secretkey sk,
                  const ccec25519base base);


long * kCryptoHashDescriptor_SHA512;

void CryptoHKDF (long * hashDescriptor,uint8_t *input,size_t input_size,uint8_t *salt,size_t salt_size,
                 uint8_t *info,size_t info_size,long out_len,uint8_t *outData);
//void CryptoHKDF (long * hashDescriptor,uint8_t *input,size_t input_size,uint8_t *salt,size_t salt_size,
//                 uint8_t *info,size_t info_size,long out_len,uint8_t *outData, uint8_t *x);

//Private function. Cannot be called
//void _chacha20_poly1305_encrypt_all
//    (uint8_t *keyData,uint8_t *nonce,size_t nonceLength,uint8_t *aadBytes,
//     size_t aadBytesLength,uint8_t *plaintextBytes,size_t plaintextLength,
//     uint8_t *outputBytes,size_t *out_len);


//Private function. Cannot be called
//int _chacha20_poly1305_decrypt_all
//(uint8_t *keyData,uint8_t *nonce,long nonce_len,uint8_t *aadBytes,size_t aad_len,
// uint8_t *enc_msg,size_t enc_msg_len,uint8_t * output,uint8_t *authTag);

int _chacha20_poly1305_decrypt_all     (uint8_t *key, uint8_t *nonce, size_t nonce_len, uint8_t *aad, size_t aad_len, uint8_t *encr_msg, size_t encr_msg_len, uint8_t *output, uint8_t *authTag, size_t authTag_len);

int chacha20_poly1305_decrypt_all_64x64(uint8_t *key, uint8_t *nonce, uint8_t *aad, size_t aad_len, uint8_t *encr_msg, size_t encr_msg_len, uint8_t *output, uint8_t *authTag);


int chacha20_poly1305_encrypt_all_64x64
(uint8_t *key,uint8_t *nonce,uint8_t *aad,size_t aad_len,uint8_t *message,
 size_t message_len,uint8_t *output,uint8_t *authTag);


void chacha20_poly1305_decrypt_all_96x32 (uint8_t *key,uint8_t *nonce,uint8_t *aad,size_t aad_len,uint8_t *encr_msg,
                                           size_t encr_msg_len,uint8_t *output,uint8_t *authTag);

void chacha20_poly1305_encrypt_all_96x32
    (uint8_t *key,uint8_t *nonce,uint8_t *aad,size_t aad_len,uint8_t *message,
     size_t message_len,uint8_t *output,uint8_t *authTag);


//Mark: Core crypto

// This is just a stub right now.
// Eventually we will optimize by platform.
struct ccchacha20poly1305_info {
    
};

extern const struct ccchacha20poly1305_info ccchacha20poly1305_info_default;


/*!
 @function      ccchacha20poly1305_decrypt_oneshot
 @abstract      Decrypt with chacha20poly1305.
 
 @param      info           Descriptor for the mode
 @param      key            Secret chacha20 key
 @param      nonce          Unique nonce per encryption
 @param      aad_nbytes     Length of the additional data in bytes
 @param      aad            Additional data to authenticate
 @param      ctext_nbytes   Length of the ciphertext in bytes
 @param      ctext          Input ciphertext
 @param      ptext          Output plaintext
 @param      tag            Expected authentication tag
 
 @discussion See RFC 7539 for details.
 
 The key is 32 bytes in length.
 
 The nonce is 12 bytes in length.
 
 The generated tag is 16 bytes in length.
 
 In-place processing is supported.
 */
int ccchacha20poly1305_decrypt_oneshot(const struct ccchacha20poly1305_info *info, const uint8_t *key, const uint8_t *nonce, size_t aad_nbytes, const void *aad, size_t ctext_nbytes, const void *ctext, void *ptext, const uint8_t *tag);


/*!
 @function      ccchacha20poly1305_encrypt_oneshot
 @abstract      Encrypt with chacha20poly1305.
 
 @param      info           Descriptor for the mode
 @param      key            Secret chacha20 key
 @param      nonce          Unique nonce per encryption
 @param      aad_nbytes     Length of the additional data in bytes
 @param      aad            Additional data to authenticate
 @param      ptext_nbytes   Length of the plaintext in bytes
 @param      ptext          Input plaintext
 @param      ctext          Output ciphertext
 @param      tag            Generated authentication tag
 
 @discussion See RFC 7539 for details.
 
 The key is 32 bytes in length.
 
 The nonce is 12 bytes in length.
 
 The generated tag is 16 bytes in length.
 
 In-place processing is supported.
 
 @warning The key-nonce pair must be unique per encryption.
 
 @warning A single message can be at most (2^38 - 64) bytes in length.
 */
int ccchacha20poly1305_encrypt_oneshot(const struct ccchacha20poly1305_info *info, const uint8_t *key, const uint8_t *nonce, size_t aad_nbytes, const void *aad, size_t ptext_nbytes, const void *ptext, void *ctext, uint8_t *tag);







//// Extra jl


/*
long * kCryptoAEADDescriptorChaCha20Poly1305;

void* CryptoAEADCreate(long * hashDescriptor, unsigned int mode, const uint8_t *key, size_t key_length, NSError *error);
void* CryptoAEADEncryptMessage(void* cryptoAEAD, uint8_t *nonce, size_t nonce_len, uint8_t *aad, size_t aad_len, uint8_t *msg, size_t msg_len, uint8_t *output,uint8_t *authTag, size_t authTag_len);
void* CryptoAEADDecryptMessage(void* cryptoAEAD, uint8_t *nonce, size_t nonce_len, uint8_t *aad, size_t aad_len, uint8_t *encr_msg, size_t encr_msg_len, uint8_t *ctext, uint8_t *authTag, size_t authTag_len);
*/

#endif /* Bindings_h */






